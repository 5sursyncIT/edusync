// src/hooks/useBatches.js
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import odooApi from '../services/odooApi.jsx';

export const useBatches = () => {
  const [batches, setBatches] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [pagination, setPagination] = useState({
    currentPage: 1,
    totalPages: 1,
    totalCount: 0,
    limit: 10,
    hasNext: false,
    hasPrev: false
  });
  const { user } = useAuth();

  // √âtat pour les filtres
  const [filters, setFilters] = useState({
    search: '',
    courseId: null,
    status: null, // upcoming, running, completed
    order: 'name asc'
  });

  // R√©cup√©rer la liste des batches
  const fetchBatches = useCallback(async (
    page = 1, 
    search = '', 
    order = 'name asc',
    courseId = null,
    status = null
  ) => {
    console.log('üîç fetchBatches: DEBUT - Param√®tres:', { page, search, order, courseId, status, user: user?.id });
    
    if (!user?.id) {
      console.log('‚ö†Ô∏è fetchBatches: Pas d\'utilisateur connect√©');
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const filterParams = {};
      if (courseId) {
        filterParams.course_id = courseId;
      }
      if (status) {
        filterParams.status = status;
      }

      console.log('üîç fetchBatches: Appel odooApi.getBatches avec params:', { page, limit: pagination.limit, search, order, filterParams });
      const result = await odooApi.getBatches(page, pagination.limit, search, order, filterParams);
      
      console.log('üîç fetchBatches: R√©sultat COMPLET de l\'API:', result);
      console.log('üîç fetchBatches: Type du r√©sultat:', typeof result);
      console.log('üîç fetchBatches: result.status:', result?.status);
      console.log('üîç fetchBatches: result.data:', result?.data);
      console.log('üîç fetchBatches: result.data.batches:', result?.data?.batches);
      console.log('üîç fetchBatches: Type de result.data.batches:', typeof result?.data?.batches);
      console.log('üîç fetchBatches: Array.isArray(result.data.batches):', Array.isArray(result?.data?.batches));
      
      // V√©rifier le format de la r√©ponse
      if (result && result.data && result.data.batches) {
        console.log('‚úÖ fetchBatches: Format correct d√©tect√© - data.batches existe');
        console.log('üìä fetchBatches: Nombre de batches re√ßus:', result.data.batches.length);
        console.log('üìä fetchBatches: Premier batch:', result.data.batches[0]);
        
        const batchesArray = result.data.batches || [];
        console.log('üîç fetchBatches: Array final √† d√©finir:', batchesArray);
        console.log('üîç fetchBatches: Type de l\'array final:', typeof batchesArray);
        console.log('üîç fetchBatches: Est-ce un array?', Array.isArray(batchesArray));
        
        setBatches(batchesArray);
        
        // Assurer que les donn√©es de pagination sont coh√©rentes
        const paginationData = result.data.pagination || {};
        setPagination({
          currentPage: parseInt(paginationData.page || page, 10) || 1,
          totalPages: parseInt(paginationData.pages || 1, 10) || 1,
          totalCount: parseInt(paginationData.total || 0, 10) || 0,
          limit: parseInt(paginationData.limit || pagination.limit, 10) || 10,
          hasNext: paginationData.has_next || false,
          hasPrev: paginationData.has_prev || false
        });
      } else {
        console.log('‚ö†Ô∏è fetchBatches: Format non standard - utilisation du fallback');
        console.log('üîç fetchBatches: result.batches:', result?.batches);
        console.log('üîç fetchBatches: result (comme tableau):', result);
        
        // Fallback pour l'ancien format
        const fallbackBatches = result.batches || result || [];
        console.log('üîç fetchBatches: Fallback batches:', fallbackBatches);
        console.log('üîç fetchBatches: Type du fallback:', typeof fallbackBatches);
        console.log('üîç fetchBatches: Est-ce un array?', Array.isArray(fallbackBatches));
        
        setBatches(fallbackBatches);
        const paginationData = result.pagination || {};
        setPagination({
          currentPage: parseInt(paginationData.currentPage || page, 10) || 1,
          totalPages: parseInt(paginationData.totalPages || 1, 10) || 1,
          totalCount: parseInt(paginationData.totalCount || 0, 10) || 0,
          limit: parseInt(paginationData.limit || pagination.limit, 10) || 10,
          hasNext: paginationData.hasNext || false,
          hasPrev: paginationData.hasPrev || false
        });
      }
      
      // Mettre √† jour les filtres
      setFilters(prev => ({
        ...prev,
        search,
        order,
        courseId,
        status
      }));

      console.log('‚úÖ fetchBatches: FIN - Donn√©es d√©finies avec succ√®s');

    } catch (err) {
      console.error('‚ùå fetchBatches: ERREUR lors de la r√©cup√©ration des promotions:', err);
      console.error('‚ùå fetchBatches: Stack trace:', err.stack);
      setError(err.message || 'Erreur lors de la r√©cup√©ration des promotions');
      setBatches([]);
    } finally {
      setLoading(false);
    }
  }, [user?.id, pagination.limit]);

  // Cr√©er un nouveau batch
  const createBatch = useCallback(async (batchData) => {
    try {
      setLoading(true);
      setError(null);
      
      const newBatch = await odooApi.createBatch(batchData);
      
      // Rafra√Æchir la liste en for√ßant le rechargement
      await fetchBatches(pagination.currentPage, filters.search, filters.order, filters.courseId, filters.status);
      
      return { success: true, data: newBatch };
    } catch (err) {
      console.error('Erreur lors de la cr√©ation de la promotion:', err);
      const errorMessage = err.message || 'Erreur lors de la cr√©ation de la promotion';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, [fetchBatches, pagination.currentPage, filters]);

  // Mettre √† jour un batch
  const updateBatch = useCallback(async (id, batchData) => {
    try {
      setLoading(true);
      setError(null);
      
      const updatedBatch = await odooApi.updateBatch(id, batchData);
      
      // Mettre √† jour localement
      setBatches(prev => prev.map(batch => 
        batch.id === id ? { ...batch, ...updatedBatch } : batch
      ));
      
      return { success: true, data: updatedBatch };
    } catch (err) {
      console.error('Erreur lors de la mise √† jour de la promotion:', err);
      const errorMessage = err.message || 'Erreur lors de la mise √† jour de la promotion';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Supprimer un batch
  const deleteBatch = useCallback(async (id) => {
    try {
      setLoading(true);
      setError(null);
      
      await odooApi.deleteBatch(id);
      
      // Rafra√Æchir la liste compl√®te
      await fetchBatches(pagination.currentPage, filters.search, filters.order, filters.courseId, filters.status);
      
      return { success: true };
    } catch (err) {
      console.error('Erreur lors de la suppression de la promotion:', err);
      const errorMessage = err.message || 'Erreur lors de la suppression de la promotion';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, [fetchBatches, pagination.currentPage, filters]);

  // R√©cup√©rer un batch sp√©cifique
  const getBatch = useCallback(async (id) => {
    try {
      setLoading(true);
      setError(null);
      
      const batch = await odooApi.getBatch(id);
      return { success: true, data: batch };
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration de la promotion:', err);
      const errorMessage = err.message || 'Erreur lors de la r√©cup√©ration de la promotion';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Changer de page
  const changePage = useCallback((newPage) => {
    fetchBatches(newPage, filters.search, filters.order, filters.courseId, filters.status);
  }, [fetchBatches, filters]);

  // Changer le nombre d'√©l√©ments par page
  const changeLimit = useCallback((newLimit) => {
    setPagination(prev => ({ ...prev, limit: newLimit }));
    fetchBatches(1, filters.search, filters.order, filters.courseId, filters.status);
  }, [fetchBatches, filters]);

  // Rechercher
  const search = useCallback((searchTerm) => {
    fetchBatches(1, searchTerm, filters.order, filters.courseId, filters.status);
  }, [fetchBatches, filters.order, filters.courseId, filters.status]);

  // Trier
  const sort = useCallback((field, direction = 'asc') => {
    const newOrder = `${field} ${direction}`;
    fetchBatches(pagination.currentPage, filters.search, newOrder, filters.courseId, filters.status);
  }, [fetchBatches, pagination.currentPage, filters.search, filters.courseId, filters.status]);

  // Filtrer par cours
  const filterByCourse = useCallback((courseId) => {
    fetchBatches(1, filters.search, filters.order, courseId, filters.status);
  }, [fetchBatches, filters.search, filters.order, filters.status]);

  // Filtrer par statut
  const filterByStatus = useCallback((status) => {
    fetchBatches(1, filters.search, filters.order, filters.courseId, status);
  }, [fetchBatches, filters.search, filters.order, filters.courseId]);

  // Rafra√Æchir
  const refresh = useCallback(() => {
    fetchBatches(pagination.currentPage, filters.search, filters.order, filters.courseId, filters.status);
  }, [fetchBatches, pagination.currentPage, filters]);

  // R√©cup√©rer les batches d'un cours
  const getBatchesByCourse = useCallback(async (courseId) => {
    try {
      const batchesList = await odooApi.getBatchesByCourse(courseId);
      return batchesList;
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des promotions du cours:', err);
      return [];
    }
  }, []);

  // Effet initial
  useEffect(() => {
    if (user?.id) {
      fetchBatches();
    }
  }, [user?.id]);

  return {
    // √âtat
    batches,
    loading,
    error,
    pagination,
    filters,
    
    // Actions CRUD
    createBatch,
    updateBatch,
    deleteBatch,
    getBatch,
    
    // Actions de liste
    fetchBatches,
    changePage,
    changeLimit,
    search,
    sort,
    filterByCourse,
    filterByStatus,
    refresh,
    getBatchesByCourse,
    
    // Helpers
    isFirstPage: pagination.currentPage === 1,
    isLastPage: pagination.currentPage === pagination.totalPages,
    isEmpty: batches.length === 0 && !loading
  };
};

// Hook pour un batch sp√©cifique avec ses √©tudiants
export const useBatch = (batchId) => {
  const [batch, setBatch] = useState(null);
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [studentsPagination, setStudentsPagination] = useState({
    currentPage: 1,
    totalPages: 1,
    totalCount: 0,
    limit: 50,
    hasNext: false,
    hasPrev: false
  });
  const { user } = useAuth();

  // R√©cup√©rer les d√©tails du batch
  const fetchBatch = useCallback(async () => {
    if (!user?.id || !batchId) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      const batchData = await odooApi.getBatch(batchId);
      console.log('Donn√©es du batch r√©cup√©r√©es:', batchData);
      
      setBatch(batchData);
      
      // Utiliser les √©tudiants directement depuis la r√©ponse du batch
      if (batchData && batchData.students) {
        setStudents(batchData.students);
        setStudentsPagination(prev => ({
          ...prev,
          totalCount: batchData.student_count || batchData.students.length,
          currentPage: 1
        }));
      }
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration de la promotion:', err);
      setError(err.message || 'Erreur lors de la r√©cup√©ration de la promotion');
      setBatch(null);
      setStudents([]);
    } finally {
      setLoading(false);
    }
  }, [batchId, user?.id]);

  // R√©cup√©rer les √©tudiants du batch (pour pagination/recherche sp√©cifique)
  const fetchBatchStudents = useCallback(async (page = 1, search = '') => {
    if (!user?.id || !batchId) {
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      // Utiliser l'API sp√©cialis√©e pour la r√©cup√©ration des √©tudiants avec pagination
      const result = await odooApi.getBatchStudents(batchId, page, studentsPagination.limit, search);
      setStudents(result.students || []);
      setStudentsPagination(result.pagination || studentsPagination);
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des √©tudiants:', err);
      setError(err.message || 'Erreur lors de la r√©cup√©ration des √©tudiants');
      setStudents([]);
    } finally {
      setLoading(false);
    }
  }, [batchId, user?.id, studentsPagination.limit]);

  // Mettre √† jour le batch
  const updateBatch = useCallback(async (batchData) => {
    try {
      setLoading(true);
      setError(null);
      
      const updatedBatch = await odooApi.updateBatch(batchId, batchData);
      setBatch(updatedBatch);
      
      return { success: true, data: updatedBatch };
    } catch (err) {
      console.error('Erreur lors de la mise √† jour de la promotion:', err);
      const errorMessage = err.message || 'Erreur lors de la mise √† jour de la promotion';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, [batchId]);

  // Ajouter un √©tudiant au batch
  const addStudent = useCallback(async (studentId) => {
    try {
      setLoading(true);
      setError(null);
      
      await odooApi.addStudentToBatch(batchId, studentId);
      
      // Rafra√Æchir la liste des √©tudiants
      await fetchBatchStudents();
      
      return { success: true };
    } catch (err) {
      console.error('Erreur lors de l\'ajout de l\'√©tudiant:', err);
      const errorMessage = err.message || 'Erreur lors de l\'ajout de l\'√©tudiant';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, [batchId, fetchBatchStudents]);

  // Retirer un √©tudiant du batch
  const removeStudent = useCallback(async (studentId) => {
    try {
      setLoading(true);
      setError(null);
      
      await odooApi.removeStudentFromBatch(batchId, studentId);
      
      // Supprimer localement
      setStudents(prev => prev.filter(student => student.id !== studentId));
      
      return { success: true };
    } catch (err) {
      console.error('Erreur lors du retrait de l\'√©tudiant:', err);
      const errorMessage = err.message || 'Erreur lors du retrait de l\'√©tudiant';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, [batchId]);

  useEffect(() => {
    fetchBatch();
  }, [fetchBatch]);

  return {
    batch,
    students,
    loading,
    error,
    studentsPagination,
    refresh: fetchBatch,
    updateBatch,
    fetchBatchStudents,
    addStudent,
    removeStudent
  };
};

// Hook pour les statistiques des batches
export const useBatchStatistics = (batchId) => {
  const [statistics, setStatistics] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();

  const fetchStatistics = useCallback(async () => {
    if (!user?.id || !batchId) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      const stats = await odooApi.getBatchStatistics(batchId);
      setStatistics(stats);
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des statistiques:', err);
      setError(err.message || 'Erreur lors de la r√©cup√©ration des statistiques');
      setStatistics(null);
    } finally {
      setLoading(false);
    }
  }, [batchId, user?.id]);

  useEffect(() => {
    fetchStatistics();
  }, [fetchStatistics]);

  return {
    statistics,
    loading,
    error,
    refresh: fetchStatistics
  };
};