// src/hooks/useAttendance.js
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuth } from '../contexts/AuthContext';
import odooApi from '../services/odooApi.jsx';

// Hook pour les pr√©sences avec pagination et filtres
export const useAttendances = (initialFilters = {}, page = 1, limit = 50) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState(initialFilters);
  const [currentPage, setCurrentPage] = useState(page);
  const { user } = useAuth();

  const fetchData = useCallback(async () => {
    if (!user?.id) {
      setLoading(false);
      setData(null);
      setError(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log('üîç useAttendances: R√©cup√©ration avec filtres:', filters);
      
      const result = await odooApi.getAttendances(currentPage, limit, '', filters);
      console.log('üîç useAttendances: R√©sultat API re√ßu:', result);
      
      // CORRECTION: Traiter le format correct {status: 'success', data: [...], pagination: {...}}
      if (result && result.status === 'success' && Array.isArray(result.data)) {
        // Transformer pour l'interface attendue par le composant
        const transformedData = {
          attendances: result.data,
          pagination: result.pagination || {}
        };
        
        console.log('üîç useAttendances: Donn√©es transform√©es:', transformedData);
        setData(transformedData);
        setError(null);
      } else {
        console.log('üîç useAttendances: Format de donn√©es inattendu:', result);
        throw new Error('Format de donn√©es inattendu');
      }
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des pr√©sences:', err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [user?.id, currentPage, limit, filters]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchData();
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [fetchData]);

  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
    setCurrentPage(1); // Retour √† la premi√®re page lors d'un changement de filtre
  }, []);

  const goToPage = useCallback((page) => {
    setCurrentPage(page);
  }, []);

  const nextPage = useCallback(() => {
    if (data?.pagination?.has_next) {
      setCurrentPage(prev => prev + 1);
    }
  }, [data]);

  const prevPage = useCallback(() => {
    if (data?.pagination?.has_prev) {
      setCurrentPage(prev => prev - 1);
    }
  }, [data]);

  return { 
    data, 
    loading, 
    error, 
    filters,
    currentPage,
    refetch: fetchData,
    updateFilters,
    goToPage,
    nextPage,
    prevPage
  };
};

// Hook pour les rapports de pr√©sence
export const useAttendanceReports = (reportType = 'summary', initialFilters = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState(initialFilters);
  const { user } = useAuth();

  const fetchData = useCallback(async () => {
    if (!user?.id) {
      setLoading(false);
      setData(null);
      setError(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log(`üîç useAttendanceReports: Type ${reportType}, Filtres:`, filters);
      
      const result = await odooApi.getAttendanceReports(reportType, filters);
      
      if (result) {
        setData(result);
        setError(null);
      } else {
        throw new Error('Donn√©es non re√ßues');
      }
    } catch (err) {
      console.error('Erreur lors de la g√©n√©ration du rapport:', err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [user?.id, reportType, filters]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchData();
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [fetchData]);

  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  }, []);

  return { 
    data, 
    loading, 
    error, 
    filters,
    refetch: fetchData,
    updateFilters
  };
};

// Hook pour les pr√©sences d'une session sp√©cifique
export const useSessionAttendances = (sessionId, date = null) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();

  const fetchData = useCallback(async () => {
    if (!sessionId) {
      setLoading(false);
      setData(null);
      setError(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log(`üîç useSessionAttendances: Session ${sessionId}, Date: ${date}`);
      
      // Utiliser l'API centralis√©e au lieu d'un appel fetch hardcod√©
      const url = `/api/attendances/session/${sessionId}${date ? `?date=${date}` : ''}`;
      console.log(`üîç useSessionAttendances: Appel de l'endpoint via odooApi: ${url}`);
      
      const result = await odooApi.makeRequest(url);
      console.log(`üîç useSessionAttendances: R√©sultat de l'API:`, result);
      
      if (result && result.status === 'success' && result.data) {
        setData(result.data);
        setError(null);
      } else {
        throw new Error(result?.message || 'Erreur lors de la r√©cup√©ration des donn√©es');
      }
    } catch (err) {
      console.error(`‚ùå Erreur lors de la r√©cup√©ration des donn√©es de la session ${sessionId}:`, err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [sessionId, date]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchData();
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [fetchData]);

  // Destructurer les donn√©es pour fournir l'interface attendue par le composant
  const attendances = data?.students || [];
  const session = data?.session || null;
  const statistics = data?.statistics || {};

  return { 
    attendances,
    session,
    statistics,
    loading, 
    error, 
    refetch: fetchData
  };
};

// Hook pour les pr√©sences d'un √©tudiant
export const useStudentAttendances = (studentId, initialFilters = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState(initialFilters);
  const { user } = useAuth();

  const fetchData = useCallback(async () => {
    if (!user?.id || !studentId) {
      setLoading(false);
      setData(null);
      setError(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log(`üîç useStudentAttendances: √âtudiant ${studentId}, Filtres:`, filters);
      
      const result = await odooApi.getAttendancesByStudent(studentId, filters);
      
      if (result) {
        setData(result);
        setError(null);
      } else {
        throw new Error('Donn√©es non re√ßues');
      }
    } catch (err) {
      console.error(`Erreur lors de la r√©cup√©ration des pr√©sences de l'√©tudiant ${studentId}:`, err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [user?.id, studentId, filters]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchData();
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [fetchData]);

  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  }, []);

  return { 
    data, 
    loading, 
    error, 
    filters,
    refetch: fetchData,
    updateFilters
  };
};

// Hook pour les sessions avec pagination et filtres
export const useSessions = (initialFilters = {}, page = 1, limit = 20) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentPage, setCurrentPage] = useState(page);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Utiliser directement initialFilters au lieu d'un √©tat interne
  // Stabiliser les filtres pour √©viter les re-renders inutiles
  const stableFilters = useMemo(() => {
    return JSON.stringify(initialFilters);
  }, [JSON.stringify(initialFilters)]);

  const fetchData = useCallback(async (forceRefresh = false) => {
    try {
      setLoading(true);
      setError(null);
      
      const filters = JSON.parse(stableFilters);
      console.log('üîç useSessions: R√©cup√©ration avec filtres:', filters, forceRefresh ? '(FORCE REFRESH)' : '');
      
      const result = await odooApi.getSessions(currentPage, limit, '', filters);
      
      console.log('üîç useSessions: R√©sultat brut de l\'API:', result);
      
      // V√©rifier si c'est une erreur d'authentification
      if (result && result.status === 'error' && result.code === 401) {
        console.log('‚ùå useSessions: Erreur d\'authentification d√©tect√©e');
        setError('Session expir√©e. Veuillez vous reconnecter.');
        setData(null);
        return;
      }
      
      // V√©rifier si c'est une erreur g√©n√©rale
      if (result && result.status === 'error') {
        console.log('‚ùå useSessions: Erreur de l\'API:', result.message);
        setError(result.message || 'Erreur lors de la r√©cup√©ration des sessions');
        setData(null);
        return;
      }
      
      // Traitement correct de la structure de donn√©es de l'API
      if (result && result.status === 'success' && result.data && result.data.sessions) {
        console.log('‚úÖ useSessions: Structure API success d√©tect√©e -', result.data.sessions.length, 'sessions');
        setData(result.data);
        setError(null);
      } else if (result && result.sessions && Array.isArray(result.sessions)) {
        console.log('‚úÖ useSessions: Structure sessions directe d√©tect√©e -', result.sessions.length, 'sessions');
        setData(result);
        setError(null);
      } else if (result && Array.isArray(result)) {
        // Cas o√π l'API retourne directement un array de sessions
        console.log('‚úÖ useSessions: Array de sessions d√©tect√© directement -', result.length, 'sessions');
        setData({ sessions: result, pagination: {} });
        setError(null);
      } else {
        console.log('‚ùå useSessions: Structure sessions manquante, result:', result);
        setError('Format de donn√©es inattendu - aucune session trouv√©e');
        setData(null);
      }
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des sessions:', err);
      
      // G√©rer sp√©cifiquement les erreurs d'authentification
      if (err.message.includes('Session expir√©e') || err.message.includes('401')) {
        setError('Session expir√©e. Veuillez vous reconnecter.');
      } else if (err.message.includes('Impossible de joindre le serveur')) {
        setError('Impossible de joindre le serveur. V√©rifiez votre connexion.');
      } else {
        setError(err.message || 'Erreur lors de la r√©cup√©ration des sessions');
      }
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [currentPage, limit, stableFilters]);

  // Fonction de rafra√Æchissement simple
  const refetch = useCallback((forceRefresh = true) => {
    console.log('üîÑ useSessions: Rafra√Æchissement manuel demand√©', forceRefresh ? '(FORCE)' : '');
    if (forceRefresh) {
      fetchData(true);
    } else {
      setRefreshTrigger(prev => prev + 1);
    }
  }, [fetchData]);

  const goToPage = useCallback((page) => {
    console.log('üìÑ useSessions: Navigation vers page:', page);
    setCurrentPage(page);
  }, []);

  // Effet principal pour charger les donn√©es
  useEffect(() => {
    fetchData();
  }, [fetchData, refreshTrigger]);

  return { 
    data, 
    loading, 
    error, 
    filters: JSON.parse(stableFilters),
    currentPage,
    refetch,
    goToPage
  };
};

// Hook pour les statistiques de pr√©sence - VERSION CORRIG√âE
export const useAttendanceStatistics = (initialFilters = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();

  // Stabiliser les filtres pour √©viter les re-renders inutiles - VERSION CORRIG√âE
  const stableFilters = useMemo(() => {
    return JSON.stringify(initialFilters);
  }, [JSON.stringify(initialFilters)]);

  const fetchData = useCallback(async () => {
    console.log('üîç DEBUG useAttendanceStatistics: D√©but fetchData');
    
    try {
      setLoading(true);
      setError(null);
      
      const parsedFilters = JSON.parse(stableFilters);
      console.log('üîç DEBUG useAttendanceStatistics: R√©cup√©ration avec filtres:', parsedFilters);
      
      // Utiliser l'API centralis√©e
      const result = await odooApi.getAttendanceStatistics(parsedFilters);
      
      console.log('üîç DEBUG useAttendanceStatistics: R√©sultat API brut:', result);
      
      // CORRECTION MAJEURE: Traiter le format correct de l'API {status: 'success', data: {...}}
      if (result && result.status === 'success') {
        // L'API retourne {status: 'success', data: {global_statistics: {...}, by_date: {...}, ...}}
        const finalData = result.data;
        console.log('üîç DEBUG useAttendanceStatistics: Donn√©es extraites:', finalData);
        console.log('üîç DEBUG useAttendanceStatistics: global_statistics disponible:', !!finalData?.global_statistics);
        setData(finalData);
        setError(null);
      } else if (result && result.data) {
        // Format alternatif
        console.log('üîç DEBUG useAttendanceStatistics: Format alternatif d√©tect√©');
        setData(result.data);
        setError(null);
      } else {
        console.log('üîç DEBUG useAttendanceStatistics: R√©ponse non r√©ussie:', result);
        setData(null);
        setError(result?.message || 'Aucune donn√©e disponible');
      }
    } catch (err) {
      console.error('‚ùå DEBUG useAttendanceStatistics: Erreur:', err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [stableFilters]); // Utiliser stableFilters comme d√©pendance

  useEffect(() => {
    console.log('üîç DEBUG useAttendanceStatistics: useEffect d√©clench√©');
    let isMounted = true;
    
    const timeoutId = setTimeout(() => {
      if (isMounted) {
        fetchData();
      }
    }, 100);

    return () => {
      isMounted = false;
      clearTimeout(timeoutId);
    };
  }, [fetchData]);

  const updateFilters = useCallback((newFilters) => {
    // Simplification : d√©l√©guer cette responsabilit√© au composant parent
    console.log('üîÑ updateFilters appel√© avec:', newFilters);
  }, []);

  return { 
    data, 
    loading, 
    error, 
    filters: JSON.parse(stableFilters),
    refetch: fetchData,
    updateFilters
  };
};

// Hook pour les sessions d'aujourd'hui - VERSION CORRIG√âE
export const useTodaySessions = (initialFilters = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();

  // Stabiliser les filtres pour √©viter les re-renders inutiles - VERSION CORRIG√âE
  const stableFilters = useMemo(() => {
    return JSON.stringify(initialFilters);
  }, [JSON.stringify(initialFilters)]);

  const fetchData = useCallback(async () => {
    console.log('üîç DEBUG useTodaySessions: D√©but fetchData');
    
    try {
      setLoading(true);
      setError(null);
      
      const parsedFilters = JSON.parse(stableFilters);
      console.log('üîç DEBUG useTodaySessions: R√©cup√©ration des sessions d\'aujourd\'hui avec filtres:', parsedFilters);
      
      // Utiliser l'API centralis√©e au lieu de fetch direct
      const result = await odooApi.getTodaySessions(parsedFilters);
      
      console.log('üîç DEBUG useTodaySessions: R√©sultat API:', result);
      
      // CORRECTION : L'API retourne {status: 'success', sessions: [...]} directement
      if (result && result.status === 'success' && result.sessions) {
        console.log('üîç DEBUG useTodaySessions: Sessions stock√©es:', result.sessions);
        setData(result.sessions);
        setError(null);
      } else if (result && result.data && result.data.sessions) {
        // Format alternatif de r√©ponse (pour compatibilit√©)
        console.log('üîç DEBUG useTodaySessions: Format alternatif - sessions stock√©es:', result.data.sessions);
        setData(result.data.sessions);
        setError(null);
      } else {
        console.log('üîç DEBUG useTodaySessions: Aucune session trouv√©e');
        setData([]);
        setError(null);
      }
    } catch (err) {
      console.error('‚ùå DEBUG useTodaySessions: Erreur:', err);
      setError(err.message);
      setData([]);
    } finally {
      setLoading(false);
    }
  }, [stableFilters]); // Utiliser stableFilters comme d√©pendance

  useEffect(() => {
    console.log('üîç DEBUG useTodaySessions: useEffect d√©clench√©');
    let isMounted = true;
    
    const timeoutId = setTimeout(() => {
      if (isMounted) {
        fetchData();
      }
    }, 100);

    return () => {
      isMounted = false;
      clearTimeout(timeoutId);
    };
  }, [fetchData]);

  return { 
    data: data || [], 
    loading, 
    error, 
    refetch: fetchData
  };
};

// Hook pour les sessions √† venir
export const useUpcomingSessions = (initialFilters = {}, days = 7) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();

  const fetchData = useCallback(async () => {
    if (!user?.id) {
      setLoading(false);
      setData(null);
      setError(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log('üîç useUpcomingSessions: R√©cup√©ration des sessions √† venir');
      
      const result = await odooApi.getUpcomingSessions(initialFilters, days);
      
      if (result && result.sessions) {
        setData(result.sessions);
        setError(null);
      } else {
        throw new Error('Format de donn√©es inattendu');
      }
    } catch (err) {
      console.error('Erreur lors de la r√©cup√©ration des sessions √† venir:', err);
      setError(err.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, [user?.id, initialFilters, days]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      fetchData();
    }, 100);

    return () => clearTimeout(timeoutId);
  }, [fetchData]);

  return { 
    data, 
    loading, 
    error, 
    refetch: fetchData
  };
};

// Hook pour les actions de pr√©sence (CRUD)
export const useAttendanceActions = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Enregistrer les pr√©sences en masse
  const bulkSaveAttendances = useCallback(async (attendanceData) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log('üíæ bulkSaveAttendances: Donn√©es re√ßues:', attendanceData);
      
      // V√©rifier que c'est un tableau
      if (!Array.isArray(attendanceData)) {
        throw new Error('Les donn√©es de pr√©sence doivent √™tre un tableau');
      }
      
      // Valider et formater chaque √©l√©ment du tableau
      const validatedData = [];
      for (let i = 0; i < attendanceData.length; i++) {
        const item = attendanceData[i];
        
        // Valider chaque √©l√©ment individuellement
        const validation = odooApi.validateAttendanceData(item);
        if (!validation.isValid) {
          throw new Error(`√âl√©ment ${i + 1}: ${validation.errors.join(', ')}`);
        }
        
        // Formater les donn√©es avec les bons types
        const formattedItem = {
          student_id: parseInt(item.student_id),
          session_id: parseInt(item.session_id),
          date: item.date,
          state: item.state,
          remarks: item.remarks || ''
        };
        
        validatedData.push(formattedItem);
      }
      
      console.log('üíæ bulkSaveAttendances: Donn√©es valid√©es et format√©es:', validatedData);
      
      const result = await odooApi.bulkCreateAttendances(validatedData);
      
      console.log('‚úÖ bulkSaveAttendances: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå bulkSaveAttendances: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Mettre √† jour une pr√©sence individuelle
  const updateAttendance = useCallback(async (attendanceId, attendanceData) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`üíæ updateAttendance: ID ${attendanceId}, Donn√©es:`, attendanceData);
      
      const result = await odooApi.updateAttendance(attendanceId, attendanceData);
      
      console.log('‚úÖ updateAttendance: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå updateAttendance: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Supprimer une pr√©sence
  const deleteAttendance = useCallback(async (attendanceId) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`üóëÔ∏è deleteAttendance: ID ${attendanceId}`);
      
      const result = await odooApi.deleteAttendance(attendanceId);
      
      console.log('‚úÖ deleteAttendance: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå deleteAttendance: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Marquer tous pr√©sents
  const markAllPresent = useCallback(async (sessionId, studentIds, date) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`‚úÖ markAllPresent: Session ${sessionId}, ${studentIds.length} √©tudiants`);
      
      const result = await odooApi.markAllPresent(sessionId, studentIds, date);
      
      console.log('‚úÖ markAllPresent: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå markAllPresent: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Marquer tous absents
  const markAllAbsent = useCallback(async (sessionId, studentIds, date) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`‚ùå markAllAbsent: Session ${sessionId}, ${studentIds.length} √©tudiants`);
      
      const result = await odooApi.markAllAbsent(sessionId, studentIds, date);
      
      console.log('‚úÖ markAllAbsent: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå markAllAbsent: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Pr√©sence rapide
  const quickAttendance = useCallback(async (studentId, sessionId, state, date, remarks) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`‚ö° quickAttendance: √âtudiant ${studentId}, √âtat ${state}`);
      
      const result = await odooApi.quickAttendance(studentId, sessionId, state, date, remarks);
      
      console.log('‚úÖ quickAttendance: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå quickAttendance: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    loading,
    error,
    bulkSaveAttendances,
    updateAttendance,
    deleteAttendance,
    markAllPresent,
    markAllAbsent,
    quickAttendance
  };
};

// Hook pour les actions de session (CRUD)
export const useSessionActions = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Cr√©er une session
  const createSession = useCallback(async (sessionData) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log('üíæ createSession: Donn√©es re√ßues:', sessionData);
      
      // Valider les donn√©es c√¥t√© client
      const validation = odooApi.validateSessionData(sessionData);
      console.log('üîç createSession: R√©sultat validation:', validation);
      
      if (!validation.isValid) {
        const errorMessage = validation.errors.join(', ');
        console.log('‚ùå createSession: Validation √©chou√©e:', errorMessage);
        setError(errorMessage);
        throw new Error(errorMessage);
      }
      
      console.log('üì° createSession: Appel API avec donn√©es valid√©es');
      const result = await odooApi.createSession(sessionData);
      
      console.log('‚úÖ createSession: R√©ponse API:', result);
      
      // V√©rifier le format de la r√©ponse
      if (result && result.status === 'success') {
        console.log('üéâ createSession: Session cr√©√©e avec succ√®s, ID:', result.data?.id);
        return { success: true, data: result.data, message: result.message };
      } else if (result && result.status === 'error') {
        console.log('‚ùå createSession: Erreur API:', result.message);
        setError(result.message);
        return { success: false, error: result.message };
      } else {
        console.log('‚ö†Ô∏è createSession: Format de r√©ponse inattendu:', result);
        const errorMsg = 'Format de r√©ponse inattendu du serveur';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
      
    } catch (err) {
      console.error('üí• createSession: Exception captur√©e:', err);
      const errorMessage = err.message || 'Erreur lors de la cr√©ation de la session';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Mettre √† jour une session
  const updateSession = useCallback(async (sessionId, sessionData) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`üíæ updateSession: ID ${sessionId}, Donn√©es:`, sessionData);
      
      // Valider les donn√©es
      const validation = odooApi.validateSessionData(sessionData);
      if (!validation.isValid) {
        const errorMessage = validation.errors.join(', ');
        console.log('‚ùå updateSession: Validation √©chou√©e:', errorMessage);
        setError(errorMessage);
        throw new Error(errorMessage);
      }
      
      const result = await odooApi.updateSession(sessionId, sessionData);
      
      console.log('‚úÖ updateSession: Succ√®s:', result);
      
      if (result && result.status === 'success') {
        return { success: true, data: result.data, message: result.message };
      } else {
        const errorMsg = result?.message || 'Erreur lors de la mise √† jour';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
      
    } catch (err) {
      console.error('‚ùå updateSession: Erreur:', err);
      const errorMessage = err.message || 'Erreur lors de la mise √† jour de la session';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Supprimer une session
  const deleteSession = useCallback(async (sessionId) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`üóëÔ∏è deleteSession: ID ${sessionId}`);
      
      const result = await odooApi.deleteSession(sessionId);
      
      console.log('‚úÖ deleteSession: Succ√®s:', result);
      
      if (result && result.status === 'success') {
        return { success: true, message: result.message };
      } else {
        const errorMsg = result?.message || 'Erreur lors de la suppression';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
      
    } catch (err) {
      console.error('‚ùå deleteSession: Erreur:', err);
      const errorMessage = err.message || 'Erreur lors de la suppression de la session';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Fonction pour effacer les erreurs
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    loading,
    error,
    createSession,
    updateSession,
    deleteSession,
    clearError
  };
};

// Hook pour l'export de donn√©es
export const useAttendanceExport = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const exportAttendances = useCallback(async (format = 'csv', filters = {}) => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`üì§ exportAttendances: Format ${format}, Filtres:`, filters);
      
      const result = await odooApi.exportAttendances(format, filters);
      
      console.log('‚úÖ exportAttendances: Succ√®s:', result);
      return result;
    } catch (err) {
      console.error('‚ùå exportAttendances: Erreur:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    loading,
    error,
    exportAttendances
  };
};